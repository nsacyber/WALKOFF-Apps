#!/usr/bin/env python

# GOXParse - Glens OpenVas XML Parser

# This script generates simple csv reports by parsing and filtering XML files generated by OpenVAS

# Project URL: https://bitbucket.org/memoryresident/goxparse
# Author URL: https://www.glenscott.net

# The following filters are implemented:
# Filter by IP Address (output single host)
# Filter by max/min CVSS score
# Filter by CVSS 'Threat Level'
# Filter by live/open host/ports in a CSV file (eg output by gnxparse.py)


import sys, argparse

try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET


def handle_opts():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Glens OpenVas XML Parser (goxparse)',
        usage='%(prog)s filename.xml [OPTIONS]',
        epilog="""\
usage examples:
    %(prog)s ./scan.xml -ips
    %(prog)s ./scan.xml -host <HOSTIP> 
    %(prog)s ./scan.xml -cvssmin 5 -cvssmax 8 
    %(prog)s ./scan.xml -threatlevel HIGH """
    )

    parser.add_argument('file', action='store',
                        help='File containing OpenVAS XML report')
    parser.add_argument('-i', '-ips', action='store_true', dest='ips',
                        help='Output unfiltered list of scanned ipv4 addresses')
    parser.add_argument('-host', action='store', dest='hostip', nargs='?', default='not_set',
                        help='Host to generate a report for')
    parser.add_argument('-cvssmin', action='store', dest='cvssmin', nargs='?', default='not_set',
                        help='Minimum CVSS level to report'),
    parser.add_argument('-cvssmax', action='store', dest='cvssmax', nargs='?', default='not_set',
                        help='Maximum CVSS level to report'),
    parser.add_argument('-threatlevel', action='store', dest='threat', nargs='?', default='not_set',
                        help='Threat Level to match, LOG/LOW/MEDIUM/HIGH/CRITICAL'),
    parser.add_argument('-matchfile', action='store', dest='matchfile', nargs='?', default='not_set',
                        help='.csv file from which to match open ports, in format HOSTIP,port1,port2,port3'),
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s 1.0 (http://bitbucket.org/memoryresident/goxparse )'
                        )

    args = parser.parse_args()

    return args


def nocase_equal(x, y):
    try:
        return x.upper() == y.upper()
    except AttributeError:
        return x == y


def parse_ips(openvas_xml_blob):
    host_ip_list = [];
    for report in openvas_xml_blob.findall('report'):
        for inner_report in report.findall('report'):
            for host in inner_report.findall('host'):
                for ipaddr in host.findall('ip'):
                    host_ip_list.append(ipaddr.text)
    return host_ip_list


def chop_port(portstring):
    # cut the portsection into service/port/protocol
    # converts from a string like "ssh (22/tcp)" into list
    # there is a difference in format between newer and older versions
    # of openvas, so the various sighted cases are covered here

    # Store port info in a dict with keys of service, protocol, port
    portinfo = {}

    # cases where port looks like "general/icmp"
    if portstring.startswith("general/"):
        portstringlist = portstring.split("/")
        portinfo['service'] = portstringlist[0]
        portinfo['protocol'] = portstringlist[1]
        portinfo['port'] = "N/A"

    # cases where port looks like "ntp(123/udp)" 
    elif "(" in portstring:
        # replace: ")" with "", the middle "(" with a /, then split the whole thing on /
        portstringlist = portstring.replace(")", "").replace(" (", "/").split("/")
        portinfo['service'] = portstringlist[0]
        portinfo['protocol'] = portstringlist[2]
        portinfo['port'] = portstringlist[1]

    # otherwise: port looks like "123/udp"
    else:
        portstringlist = portstring.split("/")
        portinfo['service'] = ""  # empty for now so will leave it blank
        portinfo['protocol'] = portstringlist[1]
        portinfo['port'] = portstringlist[0]

    return portinfo


def read_csv_file(filename):
    try:
        csvfile = open(filename)
        csvlines = csvfile.readlines()
        csvfile.close()
    except:
        sys.exit("There was a problem opening the .csv file.")

    csv_hostport_list = {}

    # 1) Read line in csv file (format host,port0,port1,port2,etc)
    # 2) Split line by commas
    # 3) Pop the host entry from the list
    # 4) All remaining entries in line should be ports so append them to currentports list
    # 5) Return a dictionary of hosts => portlists

    for hostline in csvlines:
        line = hostline.split(",")
        currenthost = line.pop(0)

        currentports = []

        for port in line:
            currentports.append(port.replace("\n", ""))  # strip newlines from port string
        csv_hostport_list[currenthost] = currentports

    return csv_hostport_list


def print_result(host_result, headerflag, csv_hostport_list):
    # Print a single result line to stdout in CSV format
    # Also print the header line if this is the first pass.

    # The csv (output) delimiter
    delimiter = ','
    # These blanks get replaced later.
    csvheader = ""
    csvportmatch = ""

    # check if the csv hostport is populated, if so add a column header and start checking for port matches
    if csv_hostport_list:
        csvheader = ('CSVPort Match' + delimiter)

        # crosscheck csv with xml results for port matches and set column value appropriately
        for ip_address in csv_hostport_list:
            # act on the ip for this host
            if ip_address == str(host_result['ip']):
                if str(host_result['port']) in csv_hostport_list[ip_address]:
                    csvportmatch = ('yes' + delimiter)
                    break  # exit loop
            else:
                csvportmatch = ('no' + delimiter)

    if headerflag == 'true':
        print 'Threat' + delimiter + 'IP' + delimiter + 'CVSS' + delimiter + 'Service' + delimiter + 'Protocol' + delimiter + 'Port' + delimiter + csvheader + 'OID' + delimiter + 'Name'

    print (
        str(host_result['threat']) + delimiter +
        str(host_result['ip']) + delimiter +
        str(host_result['cvss']) + delimiter +
        str(host_result['service']) + delimiter +
        str(host_result['protocol']) + delimiter +
        str(host_result['port']) + delimiter +
        str(csvportmatch) +
        str(host_result['oid']) + delimiter +
        str(host_result['name'])
    )


def iterate_host_results(openvas_xml_blob, filters, csv_hostport_list):
    # This will be set to false once the first header/host has been printed
    headerflag = 'true'

    # for each result in the report
    for result in openvas_xml_blob.iterfind('./report/report/results/result'):
        host_result = {}

        # chop port info ahead of time so we only do it once
        portinfo = chop_port(result.find('./port').text)

        # set all the info we want into host_result from the current result xml chunk
        host_result['ip'] = str(result.find('./host').text.strip())
        host_result['threat'] = str(result.find('./threat').text)
        host_result['cvss'] = str(result.find('./nvt/cvss_base').text)
        host_result['port'] = portinfo['port']
        host_result['protocol'] = portinfo['protocol']
        host_result['service'] = portinfo['service']
        host_result['name'] = str(result.find('./nvt/name').text)
        host_result['oid'] = str(result.find('./nvt').attrib['oid'])

        # Convert CVSS field to a float to allow some smarter range filtering later
        if (host_result['cvss'] != 'None'):
            try:
                host_result['cvss'] = float(host_result['cvss'])
            except:
                sys.exit(host_result['cvss'] + 'needs to be a number between 0.0 and 99.0')
            host_result['cvss'] = float(host_result['cvss'])

        # Filter successively. Host line must run the gauntlet to be printed.

        if (nocase_equal(filters['threat'], host_result['threat'])) or (filters['threat'] == 'ALL'):
            if (filters['ip'] == host_result['ip']) or (filters['ip'] == 'ALL'):

                # if either filter is set
                if (filters['cvssmin'] != 'not_set') or (filters['cvssmax'] != 'not_set'):

                    # check both for either/both not set and if so set them to a default
                    if (filters['cvssmin'] == 'not_set'):
                        filters['cvssmin'] = float('0.0')

                    if (filters['cvssmax'] == 'not_set'):
                        filters['cvssmax'] = float('99.9')

                    # Check if the value is not 'None'
                    if (host_result['cvss'] != 'None'):
                        # convert it to a float.
                        try:
                            host_result['cvss'] = float(host_result['cvss'])
                        except:
                            # might want something less nuclear than a sys.exit, like log it somewhere or ignore
                            sys.exit(
                                "For some reason the CVSS value listed against the host was neither a number or 'none'")

                        # if the host result is an actual number
                        # check the user hasn't given us a bad filter value for cvssmin/cvssmax
                        try:
                            cvssmin = float(filters['cvssmin'])
                            cvssmax = float(filters['cvssmax'])
                        except:
                            sys.exit("Please enter min/max CVSS scores between 0 - 10")

                        cvss = float(host_result['cvss'])

                        if (cvssmin <= cvss <= cvssmax):
                            print_result(host_result, headerflag, csv_hostport_list)
                            headerflag = 'false'
                else:
                    print_result(host_result, headerflag, csv_hostport_list)
                    headerflag = 'false'


def main():
    args = handle_opts()
    try:
        openvas_xml_blob = ET.ElementTree(file=args.file)
    except:
        sys.exit("Please specify a valid OpenVAS XML file")

    filters = {'ip': "ALL", 'cvssmin': 'not_set', 'cvssmax': 'not_set', 'threat': "ALL"}
    if args.ips == True:
        print "IPv4 Addresses for scanned hosts:"
        host_ip_list = parse_ips(openvas_xml_blob)
        for ip_address in host_ip_list:
            print (ip_address);
        sys.exit()

    if args.hostip != "not_set":
        filters['ip'] = str(args.hostip)
    if args.cvssmin != "not_set":
        filters['cvssmin'] = args.cvssmin
    if args.cvssmax != "not_set":
        filters['cvssmax'] = args.cvssmax
    if args.threat != "not_set":
        filters['threat'] = args.threat
    if args.matchfile != "not_set":
        csv_hostport_list = read_csv_file(args.matchfile)
    else:
        csv_hostport_list = ""

    iterate_host_results(openvas_xml_blob, filters, csv_hostport_list)


if __name__ == "__main__":
    main()
