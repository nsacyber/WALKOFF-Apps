import logging
import idstools.rule
import os
import re

from apps import App, action

logger = logging.getLogger(__name__)


def read_rules(path='/etc/snort/rules'):
    """
        Reads Snort rules from a directory. Takes in path to a directory with Snort rule files. 
        Defaults to /etc/snort/rules as that's the default for an installation on Ubuntu.
    """

    rules = []
    for root, _, files in os.walk(path):
        for rulefile in files:
            filerules = idstools.rule.parse_file(os.path.join(root, rulefile), None)
            for rule in filerules:
                rules.append(rule)
    return rules


@action
def find_ip_in_alert_log(ip, path='/var/log/snort/alert'):
    """
        Searches an ASCII Snort Alert log for an ip address.
        Returns True if found, and False if not.
        Arguments:
            ip: IP Address to be found as a string.
            path: Path to alert log. Defaults to default alert log location on Ubuntu.
    """
    if os.path.exists(path):
        with open(path, "r") as alertlog:
            for line in alertlog:
                if ip in line:
                    return True, "Success"
        return False, "NotFound"
    else:
        return False, "FileError"


@action
def write_alert_rule_based_on_ip(ip, file_name=None):
    """
        Writes a Snort rule to alert based on traffic incoming from an ip address.
        Arguments:
            ip: String with an ip address.
            filename: String with a path to a Snort rule file. Passed directly to writerule.
    """
    return_object = None
    if file_name is not None:
        return_object = write_rule(srcip=ip, options='msg: "Autogenerated rule to alert on '+ip+'."; '+ 'sid:'+ sid_generator() + ';', filename=file_name)
        return return_object.result, return_object.status
    else:
        return_object = write_rule(srcip=ip, options='msg: "Autogenerated rule to alert on '+ip+'."; '+ 'sid:'+ sid_generator() + ';')
        return return_object.result, return_object.status


@action
def write_rule(action='alert',
                protocol='tcp',
                srcip='$EXTERNAL_NET',
                srcport='any',
                direction='->',
                dstip='$HOME_NET',
                dstport='any',
                options=None,
                filename='/etc/snort/rules/walkoff.rules'
                ):
    """
        Writes a Snort rule.
        Arguments:
        All arguments are strings.
        action: What the rule does, like alert, log, drop, etc. Defaults to alert
        protocol: Traffic protocol, like tcp, udp, ip, or icmp. Defaults to tcp
        srcip: IP Address or identifier for the address of the source of traffic. Defaults to an identifier for an External Network.
        srcport: Port of source traffic. Defaults to any port.
        direction: either ->,  or <>. <> is for checking bidirectional traffic. Defaults to ->
        dstip: IP Address or identifier for the address of the destination of traffic. Defaults to an identifier for the Home Network.
        dstport: Port of the destination traffic. Defaults to any.
        options: Optional string containing snort options, like msg, content, sid, etc.
        filename: Path to Snort rule file where the rule will be written. Defaults to a file called walkoff.rules in the default rules folder on Ubuntu.
    """
    header = ' '.join([action, protocol, srcip, srcport, direction, dstip, dstport])
    if options is not None:
        rule = header + ' (' + options + ')'
    else:
        rule = header

    try:
        with open(filename, 'a') as rulesfile:
            rulesfile.write(rule+"\n")
    except IOError:
        return False, "Failure"

    return True, "Success"


def sid_generator(path=None):
    """
        Generates a Snort (signature) id for a rule by finding the greatest sid in the rules directory and adding 1 to that number for a new sid.
        Takes in an optional path argument that's passed to the readrules function.
    """
    maxsid = 0
    if path is not None:
        rules = read_rules(path)
    else:
        rules = read_rules()
    for rule in rules:
        if rule.sid is not None:
            if int(maxsid) < int(rule.sid):
                maxsid = int(rule.sid)
    if maxsid < 1000000:
        maxsid = maxsid + 1000000
    else:
        maxsid = maxsid + 1
    return str(maxsid)


@action
def write_alert_multi_ip(ips, filename=None, alert_log_path='/var/log/snort/alert'):
    '''
        Loops through and calls write_alert_rule_based_on_ip for each IPv4 addr
        if Snort has not already alerted on that IP.
        Arguments:
            ips: String of IPv4's comma delimited.
            filename: String with a path to a Snort rule file. Passed directly to writerule.
            alert_log_path: Path to the alert log snort writes to
    '''

    # Matches '<IPv4 Address>,' repeated unlimited times
    pattern = '^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]),)+$'

    if re.match(pattern, ips) is None:
        return False, 'FailureStringIPs'
    else:
        comma_index = 0
        for i in range(0, len(ips)):
            if (ips[i] == ','):
                ip = ips[comma_index:i]
                found = find_ip_in_alert_log(ip, alert_log_path).result

                if found:
                    comma_index = i + 1  # Need to get past the comma
                    continue

                if not write_alert_rule_based_on_ip(ips[comma_index:i], filename).result:
                    return False, 'FailureWriteRule'

                comma_index = i + 1  # Need to get past the comma

    return True, 'Success'

@action
def deletealertrulebasedonip(ip, file_name=None):
    """
        Deletes a Snort rule to alert based on traffic incoming from an ip address.
        Arguments:
            ip: String with an ip address.
            filename: String with a path to a Snort rule file. Passed directly to writerule.
    """
    found = False
    ipGroup = ip.split(" ")
    if file_name is not None:
        with open(file_name, 'r+') as f:
            #read in entire rule file and split by newline, get rid of empty item at end
            data = f.read().split("\n")[:-1]
            #overwrite file from beginning
            f.seek(0)
            for line in data:
                for myIp in ipGroup:
                    if myIp in line:
                        found = True
                #write down anything that doesn't match ips specified
                if found == False:
                    f.write(line+'\n')
                    f.truncate()
                else:
                    found = False
        return 'Success'
    else:
        return 'No File Found'


class SnortApp(App):
    """
       Snort app for walkoff.

       Args:
           name (str): Name of the app
           device (list[str]): List of associated device names

    """

    def __init__(self, name=None, device=None):
        App.__init__(self, name, device)  # Required to call superconstructor
